<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>Unleashed Flyball Team - Flyball Reaction</title>
<style>
  :root{
    --bg: #F6F8FB;
    --card: #FFFFFF;
    --primary: #f9db2e;
    --accent: #00AEEB;
    --dark: #222;
    --mid: #7b7b7b;
    --radius: 12px;
    --gap: 12px;
    --shadow: 0 10px 30px rgba(11,20,40,0.06);
    --max-width: 1080px;
    --tx: 0px;
    --ty: 0px;
    --scale: 1;
  }

  *{box-sizing:border-box}
  html{height:100%;overflow:hidden}
  body{height:100%;margin:0;overflow-x:hidden;overflow-y:auto;-webkit-overflow-scrolling:touch;background:linear-gradient(180deg,var(--bg),#eef3f9);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:var(--dark)}
  .wrap{max-width:var(--max-width);margin:16px auto;padding:16px;overflow-x:hidden}
  header{display:flex;align-items:center;gap:12px;margin-bottom:14px}
  .brand{display:flex;align-items:center;gap:12px}
  .logo img{width:56px;height:56px;border-radius:12px;display:block;align-items:center;object-fit:contain;}
  .brand h1{font-size:18px;margin:0}
  .subtitle{color:var(--mid);font-size:13px;margin-top:4px}

  .grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
  @media (max-width:920px){ .grid{grid-template-columns:1fr} }

  .card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
  .video-wrap{
    position:relative;
    overflow:hidden;
    border-radius:10px;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    max-height:60vh;
    min-height: clamp(280px, 40vh, 400px);
    touch-action:pan-x pan-y pinch-zoom;
    width:100%;
    box-sizing:border-box;
  }
  .video-inner {
    transform-origin:center center;
    transform:translate(var(--tx), var(--ty)) scale(var(--scale));
    transition:transform 0.12s linear;
    will-change:transform;
    display:flex;
    align-items:center;
    justify-content:center;
    max-width:100%;
    max-height:100%;
  }
  video {
    display:block;
    max-width:100%;
    height:auto;
    object-fit:contain;
    max-height:60vh;
    user-select:none;
    -webkit-user-drag:none;
  }
  /* Allow native fullscreen on video - reset transforms */
  video:fullscreen,
  video:-webkit-full-screen {
    position:fixed !important;
    top:0 !important;
    left:0 !important;
    width:100vw !important;
    height:100vh !important;
    max-width:100vw !important;
    max-height:100vh !important;
    object-fit:contain !important;
    transform:none !important;
    z-index:2147483647 !important;
  }
  /* Safari specific: reset parent transforms during fullscreen */
  .video-inner:has(video:-webkit-full-screen),
  .video-inner:has(video:fullscreen) {
    transform:none !important;
  }

  .controls{display:flex;gap:10px;align-items:center;margin-top:12px;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600}
  .btn-primary{background:linear-gradient(90deg,var(--primary),#c9a900);color:#111}
  .btn-accent{background:var(--accent);color:white}
  .btn-ghost{background:transparent;border:1px solid #e6e9ef;color:var(--dark)}

  .react-row{display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap}
  .react-big{flex:1;background:linear-gradient(90deg,var(--accent),#00b8f5);color:white;padding:14px;border-radius:12px;font-size:18px;box-shadow:0 8px 22px rgba(0,170,235,0.12);border:none;-webkit-tap-highlight-color:transparent;touch-action:manipulation;-webkit-user-select:none;}

  aside .card{padding:12px}
  .stat{font-size:13px;color:var(--mid)}

  /* Tabela wyników */
  .results{margin-top:10px;max-height:260px;overflow:auto;border-radius:12px;border:1px solid #e4e7f0;background:#f9fafc;}
  .results table{width:100%;border-collapse:separate;border-spacing:0;}
  .results thead th{
    position:sticky;
    top:0;
    z-index:1;
    background:#f3f5fb;
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:0.04em;
    padding:10px 10px;
    border-bottom:1px solid #e0e4f0;
  }
  .results tbody td{
    padding:8px 10px;
    font-size:13px;
    border-bottom:1px solid #edf0f7;
    background:#ffffff;
  }
  .results tbody tr:nth-child(even) td{
    background:#fdfdff;
  }
  .results tbody tr:hover td{
    background:#eef3ff;
  }
  .results td:nth-child(1){
    width:32px;
    text-align:center;
    color:#9ba3bd;
    font-weight:600;
  }
  .results td:nth-child(2){
    font-size:11px;
    color:#9ba3bd;
  }
  .results td:nth-child(3){
    text-align:right;
    font-variant-numeric:tabular-nums;
  }
  .results td:nth-child(4){
    width:140px;
  }

  .badge{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:3px 8px;
    border-radius:999px;
    font-size:11px;
    font-weight:600;
    background:#eef1fb;
    color:#555;
    white-space:nowrap;
  }

  .small{font-size:13px;color:var(--mid)}
  input,select{padding:8px;border-radius:8px;border:1px solid #e6e9ef;font-size:13px}
  input[type="number"]{width:100%}
  .row{display:flex;gap:8px}

  .zoom-panel{display:flex;gap:8px;align-items:center;margin-top:10px}
  .zoom-panel input[type="range"]{flex:1}

  @media (max-width:700px){
    .logo{width:48px;height:48px}
    .brand h1{font-size:16px}
    .react-big{font-size:18px;padding:16px}
    .video-wrap{max-height:42vh;max-width:100vw !important;width:100% !important;}
    video{max-height:42vh;max-width:100% !important;}
    .wrap{max-width:100vw;overflow-x:hidden}
    .card{max-width:100%;overflow:hidden}
    .grid{max-width:100vw;overflow-x:hidden}
  }

  .event-marker {
    position:absolute;
    top:8px;
    right:10px;
    background:rgba(255,255,255,0.9);
    color:var(--dark);
    padding:6px 8px;
    border-radius:8px;
    font-weight:600;
    font-size:13px;
    box-shadow:0 6px 18px rgba(11,20,40,0.06);
  }

  .fit-buttons{display:flex;gap:8px}
  .muted{color:var(--mid)}

  /* NOWY WYGLĄD STATYSTYK */
  .stats-shell{
    margin-top:6px;
    padding:10px 12px;
    border-radius:12px;
    background:#f5f7fc;
    border:1px solid #e1e5f4;
  }
  .stats-score{
    display:flex;
    align-items:baseline;
    justify-content:space-between;
    gap:12px;
    margin-bottom:8px;
  }
  .stats-score-main{
    display:flex;
    flex-direction:column;
    gap:2px;
  }
  .stats-score-label{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:0.08em;
    color:var(--mid);
  }
  .stats-score-value{
    font-size:26px;
    font-weight:800;
    font-variant-numeric:tabular-nums;
  }
  .stats-score-desc{
    font-size:12px;
    font-weight:600;
  }
  .stats-score-meta{
    font-size:11px;
    color:#9ba3bd;
    text-align:right;
  }

  .stats-grid{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:8px;
    margin-top:4px;
  }
  .stat-tile{
    background:#ffffff;
    border-radius:10px;
    padding:7px 9px;
    box-shadow:0 4px 10px rgba(15,23,42,0.04);
  }
  .stat-tile-label{
    font-size:11px;
    color:var(--mid);
    margin-bottom:2px;
  }
  .stat-tile-value{
    font-size:13px;
    font-weight:600;
    font-variant-numeric:tabular-nums;
  }

  .stats-footer{
    margin-top:8px;
    font-size:11px;
    color:#9ba3bd;
  }

  .stats-panel{
    margin-top:6px;
    border-radius:10px;
    padding:8px 10px;
    font-size:12px;
  }
  .stats-panel-title{
    font-weight:600;
    margin-bottom:4px;
  }
  .stats-panel-warning{
    background:#fff7f5;
    border:1px dashed #f5c2c2;
    color:#b00020;
  }

  /* Instruction overlay */
  .instruction-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: clamp(12px, 3vw, 32px);
    text-align: center;
    z-index: 5;
    border-radius: 10px;
    overflow-y: auto;
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch;
  }
  .instruction-overlay.hidden {
    display: none;
  }
  /* Hide video inner content when instruction is visible */
  .video-wrap:has(.instruction-overlay:not(.hidden)) .video-inner {
    visibility: hidden;
  }
  .instruction-title {
    font-size: clamp(16px, 3.5vw, 26px);
    font-weight: 700;
    color: #fff;
    margin-bottom: clamp(8px, 1.5vw, 20px);
    margin-top: clamp(8px, 2vw, 20px);
    flex-shrink: 0;
  }
  .instruction-title span {
    color: var(--primary);
  }
  .instruction-steps {
    display: flex;
    flex-direction: column;
    gap: clamp(6px, 1.2vw, 14px);
    width: 100%;
    max-width: 420px;
    flex-shrink: 0;
  }
  .instruction-step {
    display: flex;
    align-items: flex-start;
    gap: clamp(8px, 1.5vw, 14px);
    text-align: left;
    background: rgba(255,255,255,0.06);
    padding: clamp(8px, 1.5vw, 14px);
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .instruction-step-num {
    flex-shrink: 0;
    width: clamp(26px, 5vw, 32px);
    height: clamp(26px, 5vw, 32px);
    background: linear-gradient(135deg, var(--primary) 0%, #c9a900 100%);
    color: #111;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: clamp(12px, 2.5vw, 15px);
  }
  .instruction-step-content {
    flex: 1;
    min-width: 0;
  }
  .instruction-step-title {
    font-weight: 600;
    color: #fff;
    font-size: clamp(13px, 2.5vw, 15px);
    margin-bottom: 2px;
  }
  .instruction-step-desc {
    color: rgba(255,255,255,0.65);
    font-size: clamp(11px, 2vw, 13px);
    line-height: 1.4;
  }
  .instruction-step-key {
    display: inline-block;
    background: rgba(255,255,255,0.15);
    color: #fff;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: clamp(10px, 1.8vw, 12px);
    font-weight: 600;
    font-family: monospace;
    margin-left: 4px;
  }
  .instruction-footer {
    margin-top: clamp(14px, 2.5vw, 20px);
    color: rgba(255,255,255,0.5);
    font-size: clamp(10px, 1.8vw, 12px);
  }
  @media (max-width: 500px) {
    .instruction-step {
      padding: 10px;
    }
    .instruction-step-num {
      width: 24px;
      height: 24px;
      font-size: 11px;
    }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true">
          <img src="https://scontent-waw2-2.xx.fbcdn.net/v/t39.30808-6/529307358_1197038148893518_7517647576720036195_n.jpg?_nc_cat=102&ccb=1-7&_nc_sid=6ee11a&_nc_ohc=4Nn3zZ6vxcMQ7kNvwE9UG1n&_nc_oc=AdmFPyQxfQDPtGE9zbUZlW2QRw6ddeEo-8-TqnYUffmH36fAQEu5DaRTzvNboIA0tor1fheKaD1iIzfogDezUbFK&_nc_zt=23&_nc_ht=scontent-waw2-2.xx&_nc_gid=RvD7VEsdGz09--2-mtRVfQ&oh=00_AfoRLC7AWMpg1r_Trxt1U75brvbGJmWgU90bHeIS9SVEZw&oe=697287A9" alt="Unleashed Flyball Team" />
        </div>
        <div>
          <h1>Unleashed Flyball Team - Flyball Reaction</h1>
          <div class="subtitle">Tester czasu reakcji</div>
        </div>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div class="small muted">v3.7</div>
      </div>
    </header>

    <div class="grid">
      <!-- MAIN -->
      <main>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Test reakcji — wideo</strong>
              <div class="small muted">Wczytaj wideo, ustaw zdarzenie (E) i mierz reakcje (Space)</div>
            </div>
            <div class="small muted">Sprawdź swoją reakcję</div>
          </div>

          <div class="video-wrap" id="videoWrap">
            <div id="transformer" class="video-inner" style="--tx:0px; --ty:0px; --scale:1;">
              <video id="video" playsinline webkit-playsinline controls></video>
            </div>
            <div class="event-marker" id="eventMarker" style="display:none">Zdarzenie: <span id="eventTimeText">—</span></div>
            
            <!-- Instruction overlay -->
            <div class="instruction-overlay" id="instructionOverlay">
              <div class="instruction-steps">
                <div class="instruction-step">
                  <div class="instruction-step-num">1</div>
                  <div class="instruction-step-content">
                    <div class="instruction-step-title">Wczytaj wideo</div>
                    <div class="instruction-step-desc">Wybierz plik(i) wideo z dysku lub wklej URL. Możesz dodać wiele filmów naraz.</div>
                  </div>
                </div>
                <div class="instruction-step">
                  <div class="instruction-step-num">2</div>
                  <div class="instruction-step-content">
                    <div class="instruction-step-title">Ustaw zdarzenie</div>
                    <div class="instruction-step-desc">Przewiń do klatki, na którą chcesz reagować i naciśnij <span class="instruction-step-key">E</span></div>
                  </div>
                </div>
                <div class="instruction-step">
                  <div class="instruction-step-num">3</div>
                  <div class="instruction-step-content">
                    <div class="instruction-step-title">Rozpocznij test</div>
                    <div class="instruction-step-desc">Naciśnij <span class="instruction-step-key">S</span> lub kliknij Start. Reaguj przyciskiem <span class="instruction-step-key">Space</span> gdy zobaczysz zdarzenie.</div>
                  </div>
                </div>
              </div>
              <div class="instruction-footer">Cel: reaguj szybko, ale nie przewiduj!</div>
            </div>
          </div>

          <div class="controls" style="margin-top:12px">
            <input id="fileInput" type="file" accept="video/*" multiple style="flex:1" />
            <select id="videoList" class="small" style="min-width:180px">
              <option value="">Brak wideo</option>
            </select>
            <button class="btn btn-ghost" id="loadUrlBtn">Wczytaj URL</button>
            <button class="btn btn-primary" id="setEventBtn">Ustaw zdarzenie (E)</button>
            <div class="fit-buttons">
              <button class="btn btn-ghost" id="fitBtn">Fit</button>
              <button class="btn btn-ghost" id="smallBtn">Small</button>
              <button class="btn btn-ghost" id="medBtn">Medium</button>
              <button class="btn btn-ghost" id="largeBtn">Large</button>
            </div>
          </div>

          <div class="zoom-panel">
            <label class="small muted" for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.5" max="2.5" step="0.01" value="1" />
            <div class="small muted" id="zoomLabel">100%</div>
            <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
              <label class="small muted">Pinch & drag — działa na telefonie</label>
            </div>
          </div>

          <div class="react-row">
            <button id="reactBtn" class="react-big">Reaguj (Space)</button>
            <div style="min-width:220px">
              <div class="small muted">Ustawienia testu</div>
              <div style="display:flex;gap:8px;margin-top:8px">
                <input id="trialsCount" type="number" value="5" min="1" />
                <input id="randomFrom" type="number" value="1.5" min="0" step="0.1" />
                <input id="randomTo" type="number" value="2.5" min="0" step="0.1" />
              </div>
              <div class="small muted" style="margin-top:6px">
                Powtórzeń • Losowo od (s) • do (s) przed zdarzeniem
              </div>
              <div style="margin-top:8px;display:flex;gap:8px">
                <button class="btn btn-accent" id="startTestBtn">Start (S)</button>
                <button class="btn btn-ghost" id="stopTestBtn">Stop</button>
              </div>
              <div id="trialInfo" class="small muted" style="margin-top:8px">Brak testu.</div>
            </div>
          </div>
        </div>
      </main>

      <!-- RIGHT COLUMN -->
      <aside>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Wyniki</strong><div class="small muted">Twoje pomiary</div></div>
            <div><button class="btn btn-ghost" id="exportCsvBtn">Eksport CSV</button></div>
          </div>

          <div class="results" style="margin-top:10px">
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>Data</th>
                  <th>Reakcja (ms)</th>
                  <th>Ocena</th>
                </tr>
              </thead>
              <tbody id="resultsBody"></tbody>
            </table>
          </div>

          <div style="margin-top:10px">
            <div class="small muted">Statystyki</div>
            <div id="stats" class="stat">Brak wyników.</div>
          </div>
        </div>

        <!-- KARTA: wykres Gaussa -->
        <div class="card" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Krzywa powtarzalności</strong>
              <div class="small muted">Rozkład Twoich czasów reakcji</div>
            </div>
          </div>
          <div style="margin-top:10px">
            <canvas id="gaussCanvas" width="320" height="200" style="width:100%;height:auto;"></canvas>
            <div id="gaussInfo" class="small muted" style="margin-top:6px">
              Wykres pojawi się po zakończeniu testu (min. 3 ważne próby).
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="small muted">Uwagi</div>
          <ul class="small muted">
            <li>Użyj suwaka Zoom lub gestu pinch, aby powiększyć fragment wideo.</li>
            <li>Przeciągnij (drag/pan) aby przesunąć widok przy zoomie.</li>
            <li>Celem jest jak najwęższa krzywa (idealnie powtarzalne czasy reakcji) i brak przewidywania.</li>
          </ul>
        </div>
      </aside>
    </div>
  </div>

<script>
/* Uwaga: pomiary warto sprawdzić na realnym sprzęcie; przeglądarki różnie obsługują wideo. */

const video = document.getElementById('video');
const transformer = document.getElementById('transformer');
const videoWrap = document.getElementById('videoWrap');
const fileInput = document.getElementById('fileInput');
const videoList = document.getElementById('videoList');
const loadUrlBtn = document.getElementById('loadUrlBtn');
const setEventBtn = document.getElementById('setEventBtn');
const eventMarker = document.getElementById('eventMarker');
const eventTimeText = document.getElementById('eventTimeText');
const zoomSlider = document.getElementById('zoomSlider');
const zoomLabel = document.getElementById('zoomLabel');
const fitBtn = document.getElementById('fitBtn');
const smallBtn = document.getElementById('smallBtn');
const medBtn = document.getElementById('medBtn');
const largeBtn = document.getElementById('largeBtn');
const instructionOverlay = document.getElementById('instructionOverlay');

const reactBtn = document.getElementById('reactBtn');
const startTestBtn = document.getElementById('startTestBtn');
const stopTestBtn = document.getElementById('stopTestBtn');
const trialsCountInput = document.getElementById('trialsCount');
const randomFromInput = document.getElementById('randomFrom');
const randomToInput = document.getElementById('randomTo');
const trialInfo = document.getElementById('trialInfo');

const resultsBody = document.getElementById('resultsBody');
const statsDiv = document.getElementById('stats');
const exportCsvBtn = document.getElementById('exportCsvBtn');

/* Wykres Gaussa */
const gaussCanvas = document.getElementById('gaussCanvas');
const gaussInfo = document.getElementById('gaussInfo');
const gaussCtx = gaussCanvas.getContext('2d');

let eventTime = null;
let lastEventLabel = '';
let ongoingTest = null;
let results = [];

/* Wiele wideo */
let videoEntries = []; // { name, src, isLocal, eventTime, eventLabel }
let currentVideoIndex = -1;

/* Transform state */
let scale = parseFloat(localStorage.getItem('fly_zoom') || '1');
let tx = 0, ty = 0;
updateTransform();

/* --- Instruction overlay --- */
function hideInstructionOverlay() {
  if (instructionOverlay) {
    instructionOverlay.classList.add('hidden');
  }
}

/* --- WIELE WIDEO: pomocnicze funkcje --- */
function refreshVideoList(){
  videoList.innerHTML = '';
  if (!videoEntries.length){
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'Brak wideo';
    videoList.appendChild(opt);
    return;
  }
  videoEntries.forEach((v, i)=>{
    const opt = document.createElement('option');
    opt.value = String(i);
    let label = `${i+1}. ${v.name}`;
    if (v.eventTime != null) label += ` (E: ${v.eventTime.toFixed(2)}s)`;
    opt.textContent = label;
    if (i === currentVideoIndex) opt.selected = true;
    videoList.appendChild(opt);
  });
}

function loadVideoByIndex(index, onReady){
  const entry = videoEntries[index];
  if (!entry) return;
  currentVideoIndex = index;

  // Hide instruction overlay when video is loaded
  hideInstructionOverlay();

  try { video.pause(); } catch(_){}
  video.removeAttribute('src');
  video.load();
  video.src = entry.src;

  eventTime = entry.eventTime != null ? entry.eventTime : null;
  lastEventLabel = entry.eventLabel || '';
  updateEventUI();
  refreshVideoList();

  const handler = () => {
    video.removeEventListener('loadedmetadata', handler);
    if (typeof onReady === 'function') onReady();
  };
  if (video.readyState >= 1) {
    if (typeof onReady === 'function') onReady();
  } else {
    video.addEventListener('loadedmetadata', handler);
  }
}

/* Load file/url */
fileInput.addEventListener('change', (e)=>{
  const files = e.target.files;
  if (!files || !files.length) return;
  const URL_ = window.URL || window.webkitURL;
  for (const f of files){
    const url = URL_.createObjectURL(f);
    videoEntries.push({
      name: f.name,
      src: url,
      isLocal: true,
      eventTime: null,
      eventLabel: ''
    });
  }
  if (currentVideoIndex === -1 && videoEntries.length > 0){
    loadVideoByIndex(0);
  } else {
    refreshVideoList();
  }
});

loadUrlBtn.addEventListener('click', ()=>{
  const url = prompt('Wklej URL do pliku mp4/webm:');
  if (!url) return;
  const name = url.split('/').pop() || 'Wideo z URL';
  videoEntries.push({
    name,
    src: url,
    isLocal: false,
    eventTime: null,
    eventLabel: ''
  });
  const idx = videoEntries.length - 1;
  loadVideoByIndex(idx);
});

videoList.addEventListener('change', (e)=>{
  const idx = parseInt(e.target.value, 10);
  if (!isNaN(idx)) {
    loadVideoByIndex(idx);
  }
});

/* SET EVENT */
setEventBtn.addEventListener('click', setEventAtCurrent);
document.addEventListener('keydown', (e)=>{
  if (e.code === 'KeyE') { e.preventDefault(); setEventAtCurrent(); }
  if (e.code === 'Space') { if (ongoingTest && ongoingTest.running) { e.preventDefault(); reactNow(); } }
  if (e.code === 'KeyS') { e.preventDefault(); startTestBtn.click(); }
});

function setEventAtCurrent(){
  if (currentVideoIndex < 0 || !videoEntries[currentVideoIndex]) {
    alert('Wczytaj wideo i wybierz je z listy przed ustawieniem zdarzenia.');
    forceLayoutRecalc();
    return;
  }
  eventTime = video.currentTime;
  lastEventLabel = prompt('Opis zdarzenia (opcjonalnie):', lastEventLabel || '') || lastEventLabel;
  videoEntries[currentVideoIndex].eventTime = eventTime;
  videoEntries[currentVideoIndex].eventLabel = lastEventLabel;
  updateEventUI();
  refreshVideoList();
  alert(`Ustawiono zdarzenie dla wideo "${videoEntries[currentVideoIndex].name}": ${eventTime.toFixed(3)} s ${lastEventLabel? '— ' + lastEventLabel : ''}`);
  // Force layout recalculation after alert closes on mobile
  forceLayoutRecalc();
}

// Helper function to force layout recalculation on mobile after alert/prompt
function forceLayoutRecalc() {
  setTimeout(() => {
    // Force reflow by toggling display
    window.scrollTo(0, 0);
    
    // Reset video container dimensions
    const wrap = document.getElementById('videoWrap');
    const vid = document.getElementById('video');
    const trans = document.getElementById('transformer');
    
    if (wrap) {
      wrap.style.width = '100%';
      wrap.style.maxWidth = '100%';
    }
    if (vid) {
      vid.style.width = '';
      vid.style.maxWidth = '100%';
      vid.style.height = '';
    }
    if (trans) {
      // Ensure transformer is within bounds
      trans.style.width = '';
      trans.style.maxWidth = '100%';
    }
    
    // Force document reflow
    document.body.style.display = 'none';
    void document.body.offsetHeight; // trigger reflow
    document.body.style.display = '';
    
    // Double-check scroll position
    window.scrollTo(0, 0);
    
    // Reset visual viewport if zoomed (iOS Safari)
    if (window.visualViewport && window.visualViewport.scale !== 1) {
      // Can't directly set scale, but scrolling helps reset it
      document.documentElement.scrollLeft = 0;
      document.documentElement.scrollTop = 0;
    }
  }, 100);
}
function updateEventUI(){
  if (eventTime == null){
    eventMarker.style.display = 'none';
    eventTimeText.textContent = '—';
  } else {
    eventMarker.style.display = 'block';
    eventTimeText.textContent = eventTime.toFixed(3) + 's';
  }
}

/* --- ZOOM & PAN --- */
function updateTransform(){
  transformer.style.setProperty('--tx', `${tx}px`);
  transformer.style.setProperty('--ty', `${ty}px`);
  transformer.style.setProperty('--scale', `${scale}`);
  zoomLabel.textContent = `${Math.round(scale*100)}%`;
  zoomSlider.value = scale;
  localStorage.setItem('fly_zoom', String(scale));
}
zoomSlider.addEventListener('input', (e)=>{
  scale = parseFloat(e.target.value);
  updateTransform();
});

/* Fit / presets */
fitBtn.addEventListener('click', ()=>{ scale = 1; tx = 0; ty = 0; updateTransform(); });
smallBtn.addEventListener('click', ()=>{ scale = 0.8; tx = 0; ty = 0; updateTransform(); });
medBtn.addEventListener('click', ()=>{ scale = 1.2; tx = 0; ty = 0; updateTransform(); });
largeBtn.addEventListener('click', ()=>{ scale = 1.6; tx = 0; ty = 0; updateTransform(); });

/* PAN with pointer events */
let pointerActive = false;
let lastPointer = {x:0,y:0};
videoWrap.addEventListener('pointerdown', (e)=>{
  if (scale === 1) return;
  pointerActive = true;
  lastPointer.x = e.clientX; lastPointer.y = e.clientY;
  videoWrap.setPointerCapture(e.pointerId);
});
videoWrap.addEventListener('pointermove', (e)=>{
  if (!pointerActive) return;
  const dx = e.clientX - lastPointer.x;
  const dy = e.clientY - lastPointer.y;
  lastPointer.x = e.clientX; lastPointer.y = e.clientY;
  tx += dx;
  ty += dy;
  updateTransform();
});
videoWrap.addEventListener('pointerup', (e)=>{
  if (!pointerActive) return;
  pointerActive = false;
  try{ videoWrap.releasePointerCapture(e.pointerId); }catch(_){}
});
videoWrap.addEventListener('pointercancel', ()=>{ pointerActive=false; });

/* TOUCH: pinch-to-zoom for two fingers */
let lastPinchDist = null;
videoWrap.addEventListener('touchstart', (e)=>{
  if (e.touches && e.touches.length === 2){
    lastPinchDist = distanceBetweenTouches(e.touches[0], e.touches[1]);
  }
}, {passive:false});
videoWrap.addEventListener('touchmove', (e)=>{
  if (e.touches && e.touches.length === 2){
    e.preventDefault();
    const dist = distanceBetweenTouches(e.touches[0], e.touches[1]);
    if (lastPinchDist){
      const delta = dist - lastPinchDist;
      let factor = 1 + delta / 300;
      scale = Math.max(0.5, Math.min(2.5, scale * factor));
      updateTransform();
    }
    lastPinchDist = dist;
  }
}, {passive:false});
videoWrap.addEventListener('touchend', (e)=>{
  if (!e.touches || e.touches.length < 2) lastPinchDist = null;
});

function distanceBetweenTouches(a,b){
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return Math.sqrt(dx*dx + dy*dy);
}

/* --- Test logic: losowy start przed zdarzeniem, losowy wybór wideo --- */
startTestBtn.addEventListener('click', startTest);
stopTestBtn.addEventListener('click', stopTest);

/* Reakcja na dotyk/klik bez opóźnienia click na mobile */
reactBtn.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  reactNow();
});

function startTest(){
  if (!videoEntries.length) {
    alert('Wczytaj co najmniej jedno wideo przed testem.');
    forceLayoutRecalc();
    return;
  }

  const trials = Math.max(1, parseInt(trialsCountInput.value)||1);

  let from = parseFloat(randomFromInput.value);
  let to = parseFloat(randomToInput.value);
  if (isNaN(from)) from = 1.5;
  if (isNaN(to)) to = 2.5;
  if (from < 0) from = 0;
  if (to < 0) to = 0;
  if (to < from) { const tmp = from; from = to; to = tmp; }

  // lista indeksów filmów, które mają ustawione zdarzenie
  const videoIndices = [];
  videoEntries.forEach((v,i)=>{
    if (v.eventTime != null) videoIndices.push(i);
  });
  if (!videoIndices.length){
    alert('Ustaw punkt zdarzenia (E) na co najmniej jednym wideo przed testem.');
    forceLayoutRecalc();
    return;
  }

  results = [];
  updateResultsUI();
  ongoingTest = {
    running:true,
    trialsTotal:trials,
    currentTrial:0,
    offsetMin:from,
    offsetMax:to,
    videoIndices
  };
  
  // Enter fullscreen test mode
  enterFullscreenTestMode();
  updateFsTrialInfo('Przygotuj się...');
  
  runNextTrial();
}

function runNextTrial(){
  if (!ongoingTest || !ongoingTest.running) return;
  if (ongoingTest.currentTrial >= ongoingTest.trialsTotal){
    ongoingTest.running = false;
    trialInfo.textContent = `Test zakończony. ${results.length} wyników.`;
    updateResultsUI();
    
    // Show summary bubble instead of immediately exiting
    showTestSummary();
    
    return;
  }
  const trialIndex = ongoingTest.currentTrial + 1;

  // losujemy wideo z listy z ustawionym zdarzeniem
  const videoIndices = ongoingTest.videoIndices;
  const randomVideoIndex = videoIndices[Math.floor(Math.random() * videoIndices.length)];
  const chosenEntry = videoEntries[randomVideoIndex];

  function prepareTrial(){
    const minOffset = Math.max(0, ongoingTest.offsetMin || 0);
    const maxOffset = Math.max(minOffset, ongoingTest.offsetMax || minOffset);
    const range = maxOffset - minOffset;
    const randomBefore = range > 0 ? (minOffset + Math.random() * range) : minOffset;

    let startTime = eventTime - randomBefore;
    if (!isFinite(startTime) || startTime < 0) startTime = 0;
    if (video.duration && startTime > video.duration) {
      startTime = Math.max(0, video.duration - 0.1);
    }

    video.currentTime = startTime;
    video.pause();

    const infoText = `Próba ${trialIndex} / ${ongoingTest.trialsTotal} — ${chosenEntry.name}`;
    trialInfo.textContent = infoText + `, losowo ~${randomBefore.toFixed(2)}s przed zdarzeniem...`;
    updateFsTrialInfo(infoText);

    setTimeout(()=>{
      video.play().then(()=>{
        const playingText = `Próba ${trialIndex} / ${ongoingTest.trialsTotal} — Reaguj!`;
        trialInfo.textContent = `Próba ${trialIndex} / ${ongoingTest.trialsTotal} — wideo: ${chosenEntry.name}. Reaguj na zdarzenie.`;
        updateFsTrialInfo(playingText);
      }).catch(err=>{
        console.warn('Play rejected:', err);
        exitFullscreenTestMode();
        alert('Autoodtwarzanie zablokowane. Dotknij wideo, a potem kliknij Start ponownie.');
        forceLayoutRecalc();
      });
    }, 140);
  }

  loadVideoByIndex(randomVideoIndex, prepareTrial);
}

function reactNow(){
  if (!ongoingTest || !ongoingTest.running){
    alert('Brak trwającego testu.');
    forceLayoutRecalc();
    return;
  }

  const pressVideoTime = video.currentTime; // s
  const reactionMs = (pressVideoTime - eventTime) * 1000; // może być ujemne (za wcześnie)
  const reactionRounded = Math.round(reactionMs * 10) / 10;

  try { video.pause(); } catch(_){}

  ongoingTest.currentTrial += 1;
  const classification = classifyReaction(reactionMs);
  const note = classification.valid ? 'OK' : 'Przewidziałeś';

  const currentVideoName = videoEntries[currentVideoIndex]?.name || '';

  results.push({
    trial: ongoingTest.currentTrial,
    ms: reactionRounded,
    iso: new Date().toISOString(),
    note,
    rating: classification.label,
    valid: classification.valid,
    color: classification.color,
    videoName: currentVideoName
  });

  updateResultsUI();
  
  // Update fullscreen info with result
  const resultText = `${reactionRounded} ms — ${classification.label}`;
  updateFsTrialInfo(resultText);
  
  // Show result bubble with rating
  showResultBubble(reactionRounded, classification.label, classification.color);

  setTimeout(()=>{
    // Hide result bubble before next trial
    hideResultBubble();
    
    if (ongoingTest.currentTrial < ongoingTest.trialsTotal) {
      runNextTrial();
    } else {
      ongoingTest.running = false;
      trialInfo.textContent = `Test zakończony. ${results.length} wyników.`;
      updateResultsUI();
      
      // Show summary bubble instead of immediately exiting
      showTestSummary();
    }
  }, 700);
}

function stopTest(){
  if (!ongoingTest) return;
  ongoingTest.running = false;
  try { video.pause(); } catch(_){}
  trialInfo.textContent = 'Test zatrzymany.';
  
  // Exit fullscreen test mode when test is stopped
  exitFullscreenTestMode();
}

function classifyReaction(ms){
  const m = Math.round(ms);
  // m < 0 → PRZED zdarzeniem = przewidywanie
  if (m < 0) return { label: 'Przewidziałeś', valid: false, color: 'danger' };
  if (m < 120) return { label: 'Przewidziałeś', valid: false, color: 'danger' };
  if (m <= 170) return { label: 'Rewelacja', valid: true, color: 'gold' };
  if (m <= 240) return { label: 'Bardzo dobrze', valid: true, color: 'green' };
  if (m <= 270) return { label: 'Dobrze', valid: true, color: 'orange' };
  return { label: 'Do poprawy', valid: true, color: 'muted' };
}

/* RESULTS UI + STATYSTYKI + WYNIK KOŃCOWY + WYKRES GAUSSA */
function updateResultsUI(){
  resultsBody.innerHTML = '';
  results.forEach((r, idx)=>{
    const tr = document.createElement('tr');

    const td1 = document.createElement('td'); td1.textContent = (idx+1);

    const td2 = document.createElement('td');
    td2.textContent = r.iso.replace('T',' ').slice(0,19);

    const td3 = document.createElement('td');
    td3.textContent = `${r.ms} ms`;
    td3.style.fontWeight='700';

    const td4 = document.createElement('td');
    const badge = document.createElement('span');
    badge.className = 'badge';
    badge.textContent = r.rating || (r.note || '');

    if (r.valid === false) {
      badge.style.background = 'rgba(176,0,32,0.08)';
      badge.style.color = '#b00020';
      badge.style.border = '1px solid rgba(176,0,32,0.25)';
    } else {
      if (r.color === 'gold') {
        badge.style.background = 'rgba(249,219,46,0.12)';
        badge.style.color = '#b8860b';
        badge.style.border = '1px solid rgba(249,219,46,0.35)';
      }
      if (r.color === 'green') {
        badge.style.background = 'rgba(11,138,62,0.08)';
        badge.style.color = '#0b8a3e';
        badge.style.border = '1px solid rgba(11,138,62,0.25)';
      }
      if (r.color === 'orange') {
        badge.style.background = 'rgba(208,107,0,0.08)';
        badge.style.color = '#d06b00';
        badge.style.border = '1px solid rgba(208,107,0,0.25)';
      }
    }
    td4.appendChild(badge);

    tr.appendChild(td1); 
    tr.appendChild(td2); 
    tr.appendChild(td3); 
    tr.appendChild(td4);
    resultsBody.appendChild(tr);
  });

  const validResults = results.filter(r => r.valid === true);
  const predictedCount = results.length - validResults.length;
  const totalTrials = results.length;

  if (validResults.length < 3) {
    statsDiv.innerHTML = `
      <div class="stats-panel stats-panel-warning">
        <div class="stats-panel-title">Za mało prób do oceny wyniku</div>
        <div>
          Prób ogółem: <b>${totalTrials}</b><br/>
          Przewidzianych (za wcześnie): <b>${predictedCount}</b>
        </div>
      </div>
    `;
    drawEmptyGauss('Za mało danych do krzywej (min. 3 ważne próby).');
    return;
  }

  const nums = validResults.map(r => r.ms);
  const min = Math.min(...nums);
  const max = Math.max(...nums);

  const mean = nums.reduce((a,b)=>a+b,0) / nums.length;
  const variance = nums.reduce((sum, v)=> sum + Math.pow(v - mean, 2), 0) / nums.length;
  const stdDev = Math.sqrt(variance);

  let consistencyLabel = '';
  let consistencyColor = '';

  if (stdDev < 15) {
    consistencyLabel = 'ELITARNA POWTARZALNOŚĆ';
    consistencyColor = '#0b8a3e';
  } else if (stdDev < 30) {
    consistencyLabel = 'BARDZO DOBRA POWTARZALNOŚĆ';
    consistencyColor = '#2e7d32';
  } else if (stdDev < 50) {
    consistencyLabel = 'PRZECIĘTNA POWTARZALNOŚĆ';
    consistencyColor = '#d06b00';
  } else {
    consistencyLabel = 'NISKA POWTARZALNOŚĆ';
    consistencyColor = '#b00020';
  }

  const predictedRatio = totalTrials > 0 ? (predictedCount / totalTrials) : 0;

  // mniejsza waga szybkości, większa powtarzalności/przewidywania
  const speedScoreRaw = 100 - Math.max(0, (mean - 180) * 0.15);
  const consistencyPenalty = Math.max(0, (stdDev - 10) * 1.5);
  const predictionPenalty = predictedRatio * 200;

  let finalScore = Math.round(speedScoreRaw - consistencyPenalty - predictionPenalty);
  finalScore = Math.max(0, Math.min(100, finalScore));

  let finalLabel = '';
  let finalColor = '';

  if (finalScore >= 90) {
    finalLabel = 'MISTRZ REAKCJI (bez przewidywania)';
    finalColor = '#0b8a3e';
  } else if (finalScore >= 75) {
    finalLabel = 'Bardzo dobry wynik';
    finalColor = '#2e7d32';
  } else if (finalScore >= 60) {
    finalLabel = 'Nie najgorzej';
    finalColor = '#d06b00';
  } else {
    finalLabel = 'Słabo Ci to idzie';
    finalColor = '#b00020';
  }

  statsDiv.innerHTML = `
    <div class="stats-shell">
      <div class="stats-score">
        <div class="stats-score-main">
          <div class="stats-score-label">Ostateczny wynik</div>
          <div class="stats-score-value" style="color:${finalColor}">${finalScore}</div>
          <div class="stats-score-desc" style="color:${finalColor}">${finalLabel}</div>
        </div>
        <div class="stats-score-meta">
          Próby ważne: <b>${validResults.length}</b> / ${totalTrials}<br/>
          Przewidzianych: <b>${predictedCount}</b> (${Math.round(predictedRatio*100)}%)
        </div>
      </div>

      <div class="stats-grid">
        <div class="stat-tile">
          <div class="stat-tile-label">Średni czas</div>
          <div class="stat-tile-value">${mean.toFixed(1)} ms</div>
        </div>
        <div class="stat-tile">
          <div class="stat-tile-label">Powtarzalność (SD)</div>
          <div class="stat-tile-value" style="color:${consistencyColor}">±${stdDev.toFixed(1)} ms</div>
        </div>
        <div class="stat-tile">
          <div class="stat-tile-label">Min</div>
          <div class="stat-tile-value">${min.toFixed(1)} ms</div>
        </div>
        <div class="stat-tile">
          <div class="stat-tile-label">Max</div>
          <div class="stat-tile-value">${max.toFixed(1)} ms</div>
        </div>
      </div>

      <div class="stats-footer">
        Im wyższy wynik i niższe SD przy zerowym przewidywaniu, tym lepsza kontrola reakcji.
      </div>
    </div>
  `;

  drawGaussCurve(nums, mean, stdDev);
}

/* Rysowanie wykresu Gaussa */
function drawEmptyGauss(msg){
  if (!gaussCtx) return;
  const ctx = gaussCtx;
  const W = gaussCanvas.width;
  const H = gaussCanvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#f5f7fb';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#888';
  ctx.font = '12px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Brak danych', W/2, H/2 - 8);
  if (msg){
    ctx.fillText(msg, W/2, H/2 + 10);
  }
  gaussInfo.textContent = msg || 'Wykres pojawi się po zakończeniu testu (min. 3 ważne próby).';
}

function drawGaussCurve(samples, mean, stdDev){
  if (!gaussCtx) return;
  const ctx = gaussCtx;
  const W = gaussCanvas.width;
  const H = gaussCanvas.height;

  ctx.clearRect(0,0,W,H);

  const paddingLeft = 35;
  const paddingRight = 10;
  const paddingTop = 10;
  const paddingBottom = 22;

  const plotW = W - paddingLeft - paddingRight;
  const plotH = H - paddingTop - paddingBottom;
  const baseY = H - paddingBottom;

  if (stdDev < 1e-3) {
    ctx.fillStyle = '#f5f7fb';
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#ccd2e5';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, baseY);
    ctx.lineTo(W - paddingRight, baseY);
    ctx.stroke();

    const x = paddingLeft + plotW/2;
    ctx.strokeStyle = '#00AEEB';
    ctx.setLineDash([4,3]);
    ctx.beginPath();
    ctx.moveTo(x, baseY);
    ctx.lineTo(x, paddingTop);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = '#00AEEB';
    ctx.font = '11px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${mean.toFixed(1)} ms (idealnie powtarzalnie)`, x, paddingTop + 14);

    gaussInfo.textContent = `Średnia: ${mean.toFixed(1)} ms • SD ≈ 0 ms — prawie idealna powtarzalność.`;
    return;
  }

  const minSample = Math.min(...samples);
  const maxSample = Math.max(...samples);

  const left = Math.min(minSample, mean - 3*stdDev);
  const right = Math.max(maxSample, mean + 3*stdDev);
  const range = right - left || 1;

  function xToCanvas(val){
    return paddingLeft + ((val - left) / range) * plotW;
  }

  function normalPDF(x, mu, sigma){
    const z = (x - mu) / sigma;
    return Math.exp(-0.5 * z * z) / (sigma * Math.sqrt(2*Math.PI));
  }

  const steps = 120;
  const xs = [];
  const ys = [];
  let maxPdf = 0;
  for (let i=0;i<=steps;i++){
    const x = left + (range * i / steps);
    const pdf = normalPDF(x, mean, stdDev);
    xs.push(x);
    ys.push(pdf);
    if (pdf > maxPdf) maxPdf = pdf;
  }

  ctx.fillStyle = '#f5f7fb';
  ctx.fillRect(0,0,W,H);

  ctx.strokeStyle = '#ccd2e5';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(paddingLeft, baseY);
  ctx.lineTo(W - paddingRight, baseY);
  ctx.stroke();

  const approxStep = 20;
  const startTick = Math.ceil(left / approxStep) * approxStep;
  const endTick = Math.floor(right / approxStep) * approxStep;
  ctx.fillStyle = '#99a1bd';
  ctx.font = '10px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  for (let t = startTick; t <= endTick; t += approxStep){
    const cx = xToCanvas(t);
    ctx.strokeStyle = '#eef1f8';
    ctx.beginPath();
    ctx.moveTo(cx, baseY);
    ctx.lineTo(cx, paddingTop);
    ctx.stroke();
    ctx.fillStyle = '#99a1bd';
    ctx.fillText(t.toFixed(0), cx, baseY + 3);
  }

  ctx.strokeStyle = '#00AEEB';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ys.forEach((pdf, i)=>{
    const xVal = xs[i];
    const cx = xToCanvas(xVal);
    const norm = pdf / maxPdf;
    const cy = baseY - norm * plotH;
    if (i===0) ctx.moveTo(cx, cy);
    else ctx.lineTo(cx, cy);
  });
  ctx.stroke();

  const meanX = xToCanvas(mean);
  ctx.strokeStyle = '#f9db2e';
  ctx.setLineDash([5,3]);
  ctx.beginPath();
  ctx.moveTo(meanX, baseY);
  ctx.lineTo(meanX, paddingTop);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = '#f9db2e';
  ctx.font = '11px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(`μ = ${mean.toFixed(1)} ms`, meanX, paddingTop + 14);

  const sigma1Left = xToCanvas(mean - stdDev);
  const sigma1Right = xToCanvas(mean + stdDev);
  ctx.strokeStyle = 'rgba(0,174,235,0.35)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sigma1Left, baseY);
  ctx.lineTo(sigma1Left, paddingTop+5);
  ctx.moveTo(sigma1Right, baseY);
  ctx.lineTo(sigma1Right, paddingTop+5);
  ctx.stroke();

  ctx.fillStyle = '#00AEEB';
  ctx.font = '10px system-ui, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('-1σ', sigma1Left - 2, paddingTop + 6);
  ctx.textAlign = 'left';
  ctx.fillText('+1σ', sigma1Right + 2, paddingTop + 6);

  ctx.fillStyle = '#d06b00';
  samples.forEach(v=>{
    const cx = xToCanvas(v);
    const cy = baseY - 3;
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI*2);
    ctx.fill();
  });

  gaussInfo.textContent = `Średnia: ${mean.toFixed(1)} ms • SD: ±${stdDev.toFixed(1)} ms — im węższa krzywa, tym lepsza powtarzalność.`;
}

/* EXPORT CSV */
exportCsvBtn.addEventListener('click', ()=>{
  if (results.length === 0) { alert('Brak wyników do eksportu'); forceLayoutRecalc(); return; }
  const lines = [['trial','iso','ms','note','video']];
  results.forEach(r => lines.push([r.trial, r.iso, r.ms, r.note, r.videoName || '']));
  const csv = lines.map(l=>l.map(cell=> `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'reaction_results.csv'; a.click();
  URL.revokeObjectURL(url);
});

/* INITIALIZE on load */
window.addEventListener('load', ()=>{
  const stored = parseFloat(localStorage.getItem('fly_zoom') || '1');
  if (!isNaN(stored)){ scale = stored; updateTransform(); }
  updateResultsUI();
  refreshVideoList();
});

/* reset transform on double-tap/click */
transformer.addEventListener('dblclick', ()=>{
  scale = 1; tx = 0; ty = 0; updateTransform();
});

// Safari detection and bootstrap
const IS_SAFARI = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
let safariBootstrapped = false;

video.addEventListener('loadedmetadata', async () => {
  // Safari needs a user-initiated play to unlock video playback
  // For local files, we try to bootstrap the video
  const entry = videoEntries[currentVideoIndex];
  const isLocalFile = entry && entry.isLocal;
  
  if (IS_SAFARI && isLocalFile && !safariBootstrapped) {
    safariBootstrapped = true;
    try {
      video.muted = true;
      video.currentTime = 0;
      await video.play();
      video.pause();
      video.muted = false;
      video.currentTime = 0;
    } catch (e) {
      console.warn('Safari bootstrap failed:', e);
    }
  }
});

video.addEventListener('dragstart', (e)=> e.preventDefault());

// Handle native video fullscreen - reset transform when entering
let preFullscreenScale = 1;
let preFullscreenTx = 0;
let preFullscreenTy = 0;

function handleFullscreenChange() {
  const isFullscreen = document.fullscreenElement === video || 
                       document.webkitFullscreenElement === video ||
                       video.webkitDisplayingFullscreen;
  
  if (isFullscreen) {
    // Save current transform and reset
    preFullscreenScale = scale;
    preFullscreenTx = tx;
    preFullscreenTy = ty;
    scale = 1;
    tx = 0;
    ty = 0;
    updateTransform();
  } else {
    // Restore transform after exiting fullscreen
    scale = preFullscreenScale;
    tx = preFullscreenTx;
    ty = preFullscreenTy;
    updateTransform();
  }
}

document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
video.addEventListener('webkitbeginfullscreen', handleFullscreenChange);
video.addEventListener('webkitendfullscreen', handleFullscreenChange);

/* ======== FULLSCREEN TEST MODE ======== */
const fullscreenOverlay = document.createElement('div');
fullscreenOverlay.id = 'fullscreenOverlay';
fullscreenOverlay.innerHTML = `
  <div class="fs-video-container" id="fsVideoContainer"></div>
  <div class="fs-trial-info" id="fsTrialInfo">Przygotuj się...</div>
  <div class="fs-result-bubble" id="fsResultBubble">
    <div class="fs-result-ms" id="fsResultMs">0 ms</div>
    <div class="fs-result-rating" id="fsResultRating">—</div>
  </div>
  <div class="fs-summary-bubble" id="fsSummaryBubble">
    <div class="fs-summary-title">Podsumowanie testu</div>
    <div class="fs-summary-score">
      <span class="fs-summary-score-label">Punkty:</span>
      <span class="fs-summary-score-value" id="fsSummaryScore">0</span>
    </div>
    <div class="fs-summary-label" id="fsSummaryLabel">—</div>
    <div class="fs-summary-stats">
      <div class="fs-summary-stat">
        <span class="fs-summary-stat-label">Średni czas:</span>
        <span class="fs-summary-stat-value" id="fsSummaryMean">— ms</span>
      </div>
      <div class="fs-summary-stat">
        <span class="fs-summary-stat-label">Powtarzalność (SD):</span>
        <span class="fs-summary-stat-value" id="fsSummarySD">— ms</span>
      </div>
      <div class="fs-summary-stat">
        <span class="fs-summary-stat-label">Ważne próby:</span>
        <span class="fs-summary-stat-value" id="fsSummaryValid">0 / 0</span>
      </div>
    </div>
    <div class="fs-summary-buttons">
      <button class="fs-summary-btn fs-summary-btn-primary" id="fsSummaryAgain">Jeszcze raz</button>
      <button class="fs-summary-btn fs-summary-btn-secondary" id="fsSummaryExit">Zakończ</button>
    </div>
  </div>
  <button class="fs-react-btn" id="fsReactBtn">Reaguj (Space)</button>
`;
document.body.appendChild(fullscreenOverlay);

const fsStyle = document.createElement('style');
fsStyle.textContent = `
  #fullscreenOverlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    background: #000;
    z-index: 9999;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    overflow: hidden;
  }
  #fullscreenOverlay.active {
    display: flex !important;
  }
  .fs-video-container {
    flex: 1;
    width: 100%;
    min-height: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
  }
  .fs-video-container video {
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    pointer-events: none;
    transform: none !important;
  }
  .fs-trial-info {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    z-index: 10001;
    text-align: center;
    max-width: 90%;
  }
  .fs-result-bubble {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.5);
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 24px 40px;
    border-radius: 20px;
    text-align: center;
    z-index: 10002;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s ease, transform 0.15s ease;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    border: 2px solid rgba(255,255,255,0.1);
  }
  .fs-result-bubble.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  .fs-result-ms {
    font-size: 42px;
    font-weight: 800;
    font-variant-numeric: tabular-nums;
    margin-bottom: 8px;
  }
  .fs-result-rating {
    font-size: 20px;
    font-weight: 700;
    padding: 8px 20px;
    border-radius: 999px;
    display: inline-block;
  }
  .fs-result-bubble.rating-gold .fs-result-rating {
    background: rgba(249,219,46,0.2);
    color: #f9db2e;
    border: 2px solid rgba(249,219,46,0.5);
  }
  .fs-result-bubble.rating-green .fs-result-rating {
    background: rgba(11,138,62,0.2);
    color: #4caf50;
    border: 2px solid rgba(76,175,80,0.5);
  }
  .fs-result-bubble.rating-orange .fs-result-rating {
    background: rgba(208,107,0,0.2);
    color: #ff9800;
    border: 2px solid rgba(255,152,0,0.5);
  }
  .fs-result-bubble.rating-danger .fs-result-rating {
    background: rgba(176,0,32,0.2);
    color: #f44336;
    border: 2px solid rgba(244,67,54,0.5);
  }
  .fs-result-bubble.rating-muted .fs-result-rating {
    background: rgba(150,150,150,0.2);
    color: #aaa;
    border: 2px solid rgba(150,150,150,0.5);
  }
  /* Summary bubble styles */
  .fs-summary-bubble {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: rgba(0,0,0,0.95);
    border-radius: clamp(16px, 4vw, 24px);
    padding: clamp(20px, 5vw, 40px);
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    z-index: 50;
    min-width: clamp(280px, 80vw, 420px);
    max-width: 90vw;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    border: 2px solid rgba(249,219,46,0.3);
  }
  .fs-summary-bubble.show {
    opacity: 1;
    pointer-events: auto;
    transform: translate(-50%, -50%) scale(1);
  }
  .fs-summary-title {
    font-size: clamp(18px, 4vw, 24px);
    font-weight: 700;
    color: #fff;
    margin-bottom: clamp(15px, 4vw, 25px);
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .fs-summary-score {
    display: flex;
    align-items: baseline;
    justify-content: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  .fs-summary-score-label {
    font-size: clamp(14px, 3vw, 18px);
    color: #aaa;
  }
  .fs-summary-score-value {
    font-size: clamp(48px, 12vw, 72px);
    font-weight: 800;
    color: var(--primary);
    line-height: 1;
  }
  .fs-summary-label {
    font-size: clamp(14px, 3.5vw, 18px);
    font-weight: 600;
    padding: 8px 20px;
    border-radius: 20px;
    display: inline-block;
    margin-bottom: clamp(15px, 4vw, 25px);
  }
  .fs-summary-stats {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: clamp(20px, 5vw, 30px);
    padding: 15px;
    background: rgba(255,255,255,0.05);
    border-radius: 12px;
  }
  .fs-summary-stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: clamp(13px, 3vw, 16px);
  }
  .fs-summary-stat-label {
    color: #888;
  }
  .fs-summary-stat-value {
    color: #fff;
    font-weight: 600;
  }
  .fs-summary-buttons {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .fs-summary-btn {
    flex: 1;
    min-width: 120px;
    padding: clamp(12px, 3vw, 16px) clamp(20px, 4vw, 30px);
    border: none;
    border-radius: 12px;
    font-size: clamp(14px, 3.5vw, 18px);
    font-weight: 700;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    transition: transform 0.15s, background 0.15s;
  }
  .fs-summary-btn:active {
    transform: scale(0.97);
  }
  .fs-summary-btn-primary {
    background: linear-gradient(90deg, #00AEEB, #00b8f5);
    color: white;
  }
  .fs-summary-btn-primary:active {
    background: linear-gradient(90deg, #0090c5, #009dd5);
  }
  .fs-summary-btn-secondary {
    background: rgba(255,255,255,0.1);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.2);
  }
  .fs-summary-btn-secondary:active {
    background: rgba(255,255,255,0.15);
  }
  .fs-react-btn {
    width: calc(100% - 24px);
    max-width: 600px;
    margin: 12px auto;
    background: linear-gradient(90deg, #00AEEB, #00b8f5);
    color: white;
    padding: 24px 20px;
    border: none;
    border-radius: 16px;
    font-size: 22px;
    font-weight: 700;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    -webkit-user-select: none;
    user-select: none;
    flex-shrink: 0;
    box-shadow: 0 8px 24px rgba(0, 174, 235, 0.3);
  }
  .fs-react-btn:active {
    background: linear-gradient(90deg, #0090c5, #009dd5);
  }
  @media (max-width: 700px) {
    .fs-react-btn {
      padding: 22px 20px;
      font-size: 20px;
      width: calc(100% - 20px);
      margin: 10px auto;
      border-radius: 14px;
    }
    .fs-trial-info {
      font-size: 12px;
      padding: 6px 12px;
    }
    .fs-result-bubble {
      padding: 18px 30px;
    }
    .fs-result-ms {
      font-size: 32px;
    }
    .fs-result-rating {
      font-size: 16px;
      padding: 6px 16px;
    }
    .fs-summary-bubble {
      padding: 16px;
    }
    .fs-summary-buttons {
      flex-direction: column;
    }
    .fs-summary-btn {
      width: 100%;
    }
  }
  /* Hide native video controls in fullscreen mode */
  #fullscreenOverlay video::-webkit-media-controls {
    display: none !important;
  }
  #fullscreenOverlay video::-webkit-media-controls-enclosure {
    display: none !important;
  }
  #fullscreenOverlay video::-webkit-media-controls-panel {
    display: none !important;
  }
`;
document.head.appendChild(fsStyle);

const fsVideoContainer = document.getElementById('fsVideoContainer');
const fsTrialInfo = document.getElementById('fsTrialInfo');
const fsReactBtn = document.getElementById('fsReactBtn');
const fsResultBubble = document.getElementById('fsResultBubble');
const fsResultMs = document.getElementById('fsResultMs');
const fsResultRating = document.getElementById('fsResultRating');
const fsSummaryBubble = document.getElementById('fsSummaryBubble');
const fsSummaryScore = document.getElementById('fsSummaryScore');
const fsSummaryLabel = document.getElementById('fsSummaryLabel');
const fsSummaryMean = document.getElementById('fsSummaryMean');
const fsSummarySD = document.getElementById('fsSummarySD');
const fsSummaryValid = document.getElementById('fsSummaryValid');
const fsSummaryAgain = document.getElementById('fsSummaryAgain');
const fsSummaryExit = document.getElementById('fsSummaryExit');

let originalVideoParent = null;
let isFullscreenTestMode = false;

// Store transform state for fullscreen
let savedScale = 1;
let savedTx = 0;
let savedTy = 0;

function enterFullscreenTestMode() {
  if (isFullscreenTestMode) return;
  isFullscreenTestMode = true;
  
  // Store original parent
  originalVideoParent = video.parentElement;
  
  // Save current transform state and reset it
  savedScale = scale;
  savedTx = tx;
  savedTy = ty;
  scale = 1;
  tx = 0;
  ty = 0;
  updateTransform();
  
  // Remove controls attribute to hide native controls
  video.removeAttribute('controls');
  
  // Move video to fullscreen container
  fsVideoContainer.appendChild(video);
  
  // Show fullscreen overlay
  fullscreenOverlay.classList.add('active');
  
  // Prevent body scroll
  document.body.style.overflow = 'hidden';
  
  // Try to request fullscreen on mobile (optional, may not work on all devices)
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen().catch(() => {});
  } else if (document.documentElement.webkitRequestFullscreen) {
    document.documentElement.webkitRequestFullscreen().catch(() => {});
  }
}

function exitFullscreenTestMode() {
  if (!isFullscreenTestMode) return;
  isFullscreenTestMode = false;
  
  // Hide result bubble and summary bubble if visible
  hideResultBubble();
  hideSummaryBubble();
  
  // Exit browser fullscreen if active
  if (document.fullscreenElement || document.webkitFullscreenElement) {
    if (document.exitFullscreen) {
      document.exitFullscreen().catch(() => {});
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen().catch(() => {});
    }
  }
  
  // Hide fullscreen overlay
  fullscreenOverlay.classList.remove('active');
  
  // Reset transform to default before moving video back
  scale = 1;
  tx = 0;
  ty = 0;
  updateTransform();
  
  // Reset video element styles to prevent overflow
  video.style.width = '';
  video.style.height = '';
  video.style.maxWidth = '100%';
  video.style.transform = '';
  
  // Move video back to original container
  if (originalVideoParent) {
    originalVideoParent.appendChild(video);
  }
  
  // Restore controls attribute
  video.setAttribute('controls', '');
  
  // Restore body scroll
  document.body.style.overflow = '';
  
  // Force layout recalculation first, then restore transform
  setTimeout(() => {
    // Restore saved transform state after layout is stable
    scale = savedScale;
    tx = savedTx;
    ty = savedTy;
    updateTransform();
    
    // Force final layout recalculation on mobile
    forceLayoutRecalc();
  }, 50);
}

function updateFsTrialInfo(text) {
  fsTrialInfo.textContent = text;
}

function showResultBubble(ms, rating, colorClass) {
  // Remove all rating classes
  fsResultBubble.classList.remove('rating-gold', 'rating-green', 'rating-orange', 'rating-danger', 'rating-muted');
  
  // Add appropriate color class
  fsResultBubble.classList.add('rating-' + colorClass);
  
  // Update content
  fsResultMs.textContent = ms + ' ms';
  fsResultRating.textContent = rating;
  
  // Show bubble
  fsResultBubble.classList.add('show');
}

function hideResultBubble() {
  fsResultBubble.classList.remove('show');
}

function showSummaryBubble(score, scoreLabel, scoreColor, mean, stdDev, sdColor, validCount, totalCount) {
  // Update score
  fsSummaryScore.textContent = score;
  fsSummaryScore.style.color = scoreColor;
  
  // Update label
  fsSummaryLabel.textContent = scoreLabel;
  fsSummaryLabel.style.background = scoreColor + '20';
  fsSummaryLabel.style.color = scoreColor;
  fsSummaryLabel.style.border = '2px solid ' + scoreColor + '50';
  
  // Update stats
  fsSummaryMean.textContent = mean.toFixed(1) + ' ms';
  fsSummarySD.textContent = '±' + stdDev.toFixed(1) + ' ms';
  fsSummarySD.style.color = sdColor;
  fsSummaryValid.textContent = validCount + ' / ' + totalCount;
  
  // Hide react button when showing summary
  fsReactBtn.style.display = 'none';
  
  // Show bubble
  fsSummaryBubble.classList.add('show');
}

function hideSummaryBubble() {
  fsSummaryBubble.classList.remove('show');
  fsReactBtn.style.display = '';
}

// Calculate and show summary after test
function showTestSummary() {
  const validResults = results.filter(r => r.valid === true);
  const totalTrials = results.length;
  
  if (validResults.length < 3) {
    // Not enough data, show simplified summary
    showSummaryBubble(
      '?',
      'Za mało ważnych prób',
      '#888',
      0,
      0,
      '#888',
      validResults.length,
      totalTrials
    );
    return;
  }
  
  const nums = validResults.map(r => r.ms);
  const mean = nums.reduce((a, b) => a + b, 0) / nums.length;
  const variance = nums.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / nums.length;
  const stdDev = Math.sqrt(variance);
  
  // Calculate consistency color
  let sdColor = '#b00020';
  if (stdDev < 15) sdColor = '#0b8a3e';
  else if (stdDev < 30) sdColor = '#2e7d32';
  else if (stdDev < 50) sdColor = '#d06b00';
  
  // Calculate final score (same as in updateResultsUI)
  const predictedCount = totalTrials - validResults.length;
  const predictedRatio = totalTrials > 0 ? (predictedCount / totalTrials) : 0;
  const speedScoreRaw = 100 - Math.max(0, (mean - 180) * 0.15);
  const consistencyPenalty = Math.max(0, (stdDev - 10) * 1.5);
  const predictionPenalty = predictedRatio * 200;
  let finalScore = Math.round(speedScoreRaw - consistencyPenalty - predictionPenalty);
  finalScore = Math.max(0, Math.min(100, finalScore));
  
  let finalLabel = '';
  let finalColor = '';
  if (finalScore >= 90) {
    finalLabel = 'MISTRZ REAKCJI!';
    finalColor = '#0b8a3e';
  } else if (finalScore >= 75) {
    finalLabel = 'Bardzo dobry wynik';
    finalColor = '#2e7d32';
  } else if (finalScore >= 60) {
    finalLabel = 'Nie najgorzej';
    finalColor = '#d06b00';
  } else {
    finalLabel = 'Słabo Ci to idzie';
    finalColor = '#b00020';
  }
  
  showSummaryBubble(finalScore, finalLabel, finalColor, mean, stdDev, sdColor, validResults.length, totalTrials);
}

// Fullscreen react button handler
fsReactBtn.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  reactNow();
});

// Summary button handlers
fsSummaryAgain.addEventListener('click', () => {
  hideSummaryBubble();
  // Reset and start new test with same settings
  results = [];
  updateResultsUI();
  startTest();
});

fsSummaryExit.addEventListener('click', () => {
  exitFullscreenTestMode();
});
</script>
</body>
</html>
