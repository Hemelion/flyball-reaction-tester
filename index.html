<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Unleashed Flyball Team - Flyball Reaction</title>
<style>
  :root{
    --bg: #F6F8FB;
    --card: #FFFFFF;
    --primary: #f9db2e;   /* yellow from hoodie */
    --accent: #00AEEB;    /* cyan accent */
    --dark: #222;
    --mid: #7b7b7b;
    --radius: 12px;
    --gap: 12px;
    --shadow: 0 10px 30px rgba(11,20,40,0.06);
    --max-width: 1080px;
    --tx: 0px;
    --ty: 0px;
    --scale: 1;
  }

  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#eef3f9);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:var(--dark)}
  .wrap{max-width:var(--max-width);margin:16px auto;padding:16px}
  header{display:flex;align-items:center;gap:12px;margin-bottom:14px}
  .brand{display:flex;align-items:center;gap:12px}
  .logo img{width:56px;height:56px;border-radius:12px;display:block;align-items:center;object-fit:contain;}
  .brand h1{font-size:18px;margin:0}
  .subtitle{color:var(--mid);font-size:13px;margin-top:4px}

  .grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
  @media (max-width:920px){ .grid{grid-template-columns:1fr} }

  .card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
  .video-wrap{
    position:relative;
    overflow:hidden;
    border-radius:10px;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    max-height: 60vh; /* gwarantuje UI widoczne */
    touch-action: none;
  }
  .video-inner {
    transform-origin: center center;
    transform: translate(var(--tx), var(--ty)) scale(var(--scale));
    transition: transform 0.12s linear;
    will-change: transform;
    display:block;
  }
  video {
    display:block;
    width:100%;
    height:auto;
    object-fit:contain;
    max-height: 60vh;
    user-select:none;
    -webkit-user-drag: none;
  }

  .controls{display:flex;gap:10px;align-items:center;margin-top:12px;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600}
  .btn-primary{background:linear-gradient(90deg,var(--primary),#c9a900);color:#111}
  .btn-accent{background:var(--accent);color:white}
  .btn-ghost{background:transparent;border:1px solid #e6e9ef;color:var(--dark)}

  .react-row{display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap}
  .react-big{flex:1;background:linear-gradient(90deg,var(--accent),#00b8f5);color:white;padding:14px;border-radius:12px;font-size:18px;box-shadow:0 8px 22px rgba(0,170,235,0.12);border:none;-webkit-tap-highlight-color:transparent;touch-action:manipulation;-webkit-user-select:none;}

  aside .card{padding:12px}
  .stat{font-size:13px;color:var(--mid)}
  .results{margin-top:10px;max-height:260px;overflow:auto}
  table{width:100%;border-collapse:collapse}
  td,th{padding:8px;border-bottom:1px solid #f1f4f8;font-size:13px}
  th{color:var(--mid);text-align:left;font-weight:700}

  .small{font-size:13px;color:var(--mid)}
  input,select{padding:8px;border-radius:8px;border:1px solid #e6e9ef;width:100%}
  .row{display:flex;gap:8px}

  .zoom-panel{display:flex;gap:8px;align-items:center;margin-top:10px}
  .zoom-panel input[type="range"]{flex:1}

  @media (max-width:700px){
    .logo{width:48px;height:48px}
    .brand h1{font-size:16px}
    .react-big{font-size:18px;padding:16px}
    .video-wrap{max-height:42vh}
    video{max-height:42vh}
  }

  .event-marker {
    position:absolute;
    top:8px;
    right:10px;
    background:rgba(255,255,255,0.9);
    color:var(--dark);
    padding:6px 8px;
    border-radius:8px;
    font-weight:600;
    font-size:13px;
    box-shadow:0 6px 18px rgba(11,20,40,0.06);
  }

  .fit-buttons{display:flex;gap:8px}
  .muted{color:var(--mid)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true">
          <img src="https://scontent-waw2-2.xx.fbcdn.net/v/t39.30808-6/529307358_1197038148893518_7517647576720036195_n.jpg?_nc_cat=102&ccb=1-7&_nc_sid=6ee11a&_nc_ohc=4Nn3zZ6vxcMQ7kNvwE9UG1n&_nc_oc=AdmFPyQxfQDPtGE9zbUZlW2QRw6ddeEo-8-TqnYUffmH36fAQEu5DaRTzvNboIA0tor1fheKaD1iIzfogDezUbFK&_nc_zt=23&_nc_ht=scontent-waw2-2.xx&_nc_gid=RvD7VEsdGz09--2-mtRVfQ&oh=00_AfoRLC7AWMpg1r_Trxt1U75brvbGJmWgU90bHeIS9SVEZw&oe=697287A9" alt="Unleashed Flyball Team" />
        </div>
        <div>
          <h1>Unleashed Flyball Team - Flyball Reaction</h1>
          <div class="subtitle">Tester czasu reakcji</div>
        </div>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div class="small muted">v1.7</div>
      </div>
    </header>

    <div class="grid">
      <!-- MAIN -->
      <main>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Test reakcji — wideo</strong>
              <div class="small muted">Wczytaj wideo, ustaw zdarzenie (E) i mierz reakcje (Space)</div>
            </div>
            <div class="small muted">Sprawdź swoją reakcję</div>
          </div>

          <div class="video-wrap" id="videoWrap">
            <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center">
              <div id="transformer" class="video-inner" style="--tx:0px; --ty:0px; --scale:1;">
                <video id="video" playsinline webkit-playsinline controls crossorigin="anonymous"></video>
              </div>
            </div>
            <div class="event-marker" id="eventMarker" style="display:none">Zdarzenie: <span id="eventTimeText">—</span></div>
          </div>

          <div class="controls" style="margin-top:12px">
            <input id="fileInput" type="file" accept="video/*" style="flex:1" />
            <button class="btn btn-ghost" id="loadUrlBtn">Wczytaj URL</button>
            <button class="btn btn-primary" id="setEventBtn">Ustaw zdarzenie (E)</button>
            <div class="fit-buttons">
              <button class="btn btn-ghost" id="fitBtn">Fit</button>
              <button class="btn btn-ghost" id="smallBtn">Small</button>
              <button class="btn btn-ghost" id="medBtn">Medium</button>
              <button class="btn btn-ghost" id="largeBtn">Large</button>
            </div>
          </div>

          <div class="zoom-panel">
            <label class="small muted" for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.5" max="2.5" step="0.01" value="1" />
            <div class="small muted" id="zoomLabel">100%</div>
            <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
              <label class="small muted">Pinch & drag — działa na telefonie</label>
            </div>
          </div>

          <div class="react-row">
            <button id="reactBtn" class="react-big">Reaguj (Space)</button>
            <div style="min-width:220px">
              <div class="small muted">Ustawienia testu</div>
              <div style="display:flex;gap:8px;margin-top:8px">
                <input id="trialsCount" type="number" value="5" min="1" />
                <input id="startOffset" type="number" value="0" min="0" step="0.1" />
                <input id="preRoll" type="number" value="1.5" min="0" step="0.1" />
              </div>
              <div class="small muted" style="margin-top:6px">Powtórzeń • Start od (s) • Przewinięcie przed (s)</div>
              <div style="margin-top:8px;display:flex;gap:8px">
                <button class="btn btn-accent" id="startTestBtn">Start (S)</button>
                <button class="btn btn-ghost" id="stopTestBtn">Stop</button>
              </div>
              <div id="trialInfo" class="small muted" style="margin-top:8px">Brak testu.</div>
            </div>
          </div>
        </div>
      </main>

      <!-- RIGHT COLUMN -->
      <aside>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Wyniki</strong><div class="small muted">Twoje pomiary</div></div>
            <div><button class="btn btn-ghost" id="exportCsvBtn">Eksport CSV</button></div>
          </div>

          <div class="results" style="margin-top:10px">
            <table>
              <thead><tr><th>#</th><th>Data</th><th>Reakcja (ms)</th><th>Uwagi</th></tr></thead>
              <tbody id="resultsBody"></tbody>
            </table>
          </div>

          <div style="margin-top:10px">
            <div class="small muted">Statystyki</div>
            <div id="stats" class="stat">Brak wyników.</div>
          </div>
        </div>

        <!-- NOWA KARTA: wykres Gaussa -->
        <div class="card" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Krzywa powtarzalności</strong>
              <div class="small muted">Rozkład Twoich czasów reakcji</div>
            </div>
          </div>
          <div style="margin-top:10px">
            <canvas id="gaussCanvas" width="320" height="200" style="width:100%;height:auto;"></canvas>
            <div id="gaussInfo" class="small muted" style="margin-top:6px">
              Wykres pojawi się po zakończeniu testu (min. 3 ważne próby).
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="small muted">Uwagi</div>
          <ul class="small muted">
            <li>Użyj suwaka Zoom lub gestu pinch, aby powiększyć fragment wideo.</li>
            <li>Przeciągnij (drag/pan) aby przesunąć widok przy zoomie.</li>
            <li>Celem jest jak najwęższa krzywa (idealnie powtarzalne czasy reakcji).</li>
          </ul>
        </div>
      </aside>
    </div>
  </div>

<script>
/* Pełna funkcjonalność: zoom, pan, pinch, test reakcji, statystyki, wykres Gaussa */
/* Uwaga: pomiary czasów warto dodatkowo weryfikować w realnej przeglądarce/urządzeniu. */

const video = document.getElementById('video');
const transformer = document.getElementById('transformer');
const videoWrap = document.getElementById('videoWrap');
const fileInput = document.getElementById('fileInput');
const loadUrlBtn = document.getElementById('loadUrlBtn');
const setEventBtn = document.getElementById('setEventBtn');
const eventMarker = document.getElementById('eventMarker');
const eventTimeText = document.getElementById('eventTimeText');
const zoomSlider = document.getElementById('zoomSlider');
const zoomLabel = document.getElementById('zoomLabel');
const fitBtn = document.getElementById('fitBtn');
const smallBtn = document.getElementById('smallBtn');
const medBtn = document.getElementById('medBtn');
const largeBtn = document.getElementById('largeBtn');

const reactBtn = document.getElementById('reactBtn');
const startTestBtn = document.getElementById('startTestBtn');
const stopTestBtn = document.getElementById('stopTestBtn');
const trialsCountInput = document.getElementById('trialsCount');
const startOffsetInput = document.getElementById('startOffset');
const preRollInput = document.getElementById('preRoll');
const trialInfo = document.getElementById('trialInfo');

const resultsBody = document.getElementById('resultsBody');
const statsDiv = document.getElementById('stats');
const exportCsvBtn = document.getElementById('exportCsvBtn');

/* Wykres Gaussa */
const gaussCanvas = document.getElementById('gaussCanvas');
const gaussInfo = document.getElementById('gaussInfo');
const gaussCtx = gaussCanvas.getContext('2d');

let currentVideoKey = null;
let currentFileObject = null;
let eventTime = null;
let lastEventLabel = '';
let ongoingTest = null;
let results = [];

/* Transform state */
let scale = parseFloat(localStorage.getItem('fly_zoom') || '1');
let tx = 0, ty = 0; // pixels
updateTransform();

/* Helpers: identyfikacja wideo (zostawione, gdybyś chciał wrócić do zapisu zdarzeń) */
function setVideoIdentityFromFile(f){
  currentFileObject = f;
  currentVideoKey = `file:${f.name}|${f.size}|${f.lastModified}`;
}
function setVideoIdentityFromUrl(url){
  currentFileObject = null;
  currentVideoKey = `url:${url}`;
}

/* Load file/url */
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  video.src = url;
  video.load();
  setVideoIdentityFromFile(f);
  eventTime = null; updateEventUI();
  tx = 0; ty = 0; updateTransform();
});

loadUrlBtn.addEventListener('click', ()=>{
  const url = prompt('Wklej URL do pliku mp4/webm:');
  if (!url) return;
  video.src = url;
  video.crossOrigin = 'anonymous';
  video.load();
  setVideoIdentityFromUrl(url);
  eventTime = null; updateEventUI();
  tx = 0; ty = 0; updateTransform();
});

/* SET EVENT */
setEventBtn.addEventListener('click', setEventAtCurrent);
document.addEventListener('keydown', (e)=>{
  if (e.code === 'KeyE') { e.preventDefault(); setEventAtCurrent(); }
  if (e.code === 'Space') { if (ongoingTest && ongoingTest.running) { e.preventDefault(); reactNow(); } }
  if (e.code === 'KeyS') { e.preventDefault(); startTestBtn.click(); }
});

function setEventAtCurrent(){
  if (!video.src) { alert('Wczytaj wideo najpierw.'); return; }
  eventTime = video.currentTime;
  lastEventLabel = prompt('Opis zdarzenia (opcjonalnie):', lastEventLabel || '') || lastEventLabel;
  updateEventUI();
  alert(`Ustawiono zdarzenie: ${eventTime.toFixed(3)} s ${lastEventLabel? '— ' + lastEventLabel : ''}`);
}
function updateEventUI(){
  if (eventTime == null){ eventMarker.style.display = 'none'; eventTimeText.textContent = '—'; }
  else { eventMarker.style.display = 'block'; eventTimeText.textContent = eventTime.toFixed(3) + 's'; }
}

/* --- ZOOM & PAN --- */
function updateTransform(){
  transformer.style.setProperty('--tx', `${tx}px`);
  transformer.style.setProperty('--ty', `${ty}px`);
  transformer.style.setProperty('--scale', `${scale}`);
  zoomLabel.textContent = `${Math.round(scale*100)}%`;
  zoomSlider.value = scale;
  localStorage.setItem('fly_zoom', String(scale));
}
zoomSlider.addEventListener('input', (e)=>{
  scale = parseFloat(e.target.value);
  updateTransform();
});

/* Fit / presets */
fitBtn.addEventListener('click', ()=>{ scale = 1; tx = 0; ty = 0; updateTransform(); });
smallBtn.addEventListener('click', ()=>{ scale = 0.8; tx = 0; ty = 0; updateTransform(); });
medBtn.addEventListener('click', ()=>{ scale = 1.2; tx = 0; ty = 0; updateTransform(); });
largeBtn.addEventListener('click', ()=>{ scale = 1.6; tx = 0; ty = 0; updateTransform(); });

/* PAN with pointer events (mouse & single-touch) */
let pointerActive = false;
let lastPointer = {x:0,y:0};
videoWrap.addEventListener('pointerdown', (e)=>{
  if (scale === 1) return;
  pointerActive = true;
  lastPointer.x = e.clientX; lastPointer.y = e.clientY;
  videoWrap.setPointerCapture(e.pointerId);
});
videoWrap.addEventListener('pointermove', (e)=>{
  if (!pointerActive) return;
  const dx = e.clientX - lastPointer.x;
  const dy = e.clientY - lastPointer.y;
  lastPointer.x = e.clientX; lastPointer.y = e.clientY;
  tx += dx;
  ty += dy;
  updateTransform();
});
videoWrap.addEventListener('pointerup', (e)=>{ if (!pointerActive) return; pointerActive=false; try{ videoWrap.releasePointerCapture(e.pointerId); }catch(e){} });
videoWrap.addEventListener('pointercancel', ()=>{ pointerActive=false; });

/* TOUCH: pinch-to-zoom for two fingers */
let lastPinchDist = null;
videoWrap.addEventListener('touchstart', (e)=>{
  if (e.touches && e.touches.length === 2){
    lastPinchDist = distanceBetweenTouches(e.touches[0], e.touches[1]);
  }
}, {passive:false});
videoWrap.addEventListener('touchmove', (e)=>{
  if (e.touches && e.touches.length === 2){
    e.preventDefault();
    const dist = distanceBetweenTouches(e.touches[0], e.touches[1]);
    if (lastPinchDist){
      const delta = dist - lastPinchDist;
      let factor = 1 + delta / 300;
      scale = Math.max(0.5, Math.min(2.5, scale * factor));
      updateTransform();
    }
    lastPinchDist = dist;
  }
}, {passive:false});
videoWrap.addEventListener('touchend', (e)=>{ if (!e.touches || e.touches.length < 2) lastPinchDist = null; });

function distanceBetweenTouches(a,b){
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return Math.sqrt(dx*dx + dy*dy);
}

/* --- Test logic --- */
startTestBtn.addEventListener('click', startTest);
stopTestBtn.addEventListener('click', stopTest);

/* Natychmiastowa reakcja na dotyk/klik (bez opóźnienia click na mobile) */
reactBtn.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  reactNow();
});

function startTest(){
  if (!video.src) { alert('Wczytaj wideo najpierw'); return; }
  if (eventTime == null) { alert('Ustaw punkt zdarzenia (E) przed testem'); return; }
  const trials = Math.max(1, parseInt(trialsCountInput.value)||1);
  const startOffset = parseFloat(startOffsetInput.value) || 0;
  const preRoll = parseFloat(preRollInput.value) || 0;
  results = [];
  updateResultsUI();
  ongoingTest = {
    running:true,
    trialsTotal:trials,
    currentTrial:0,
    startOffset,
    preRoll,
    expectedEventPerfTime: null,
    startPerfOffset: null,
    eventPerfTime: null,
    raf: null
  };
  runNextTrial();
}

function runNextTrial(){
  if (!ongoingTest || !ongoingTest.running) return;
  if (ongoingTest.currentTrial >= ongoingTest.trialsTotal){
    ongoingTest.running = false;
    trialInfo.textContent = `Test zakończony. ${results.length} wyników.`;
    updateResultsUI();
    return;
  }
  const trialIndex = ongoingTest.currentTrial + 1;
  trialInfo.textContent = `Próba ${trialIndex} / ${ongoingTest.trialsTotal} — przygotowanie...`;
  const startPos = Math.max(0, Math.min(video.duration || Infinity, ongoingTest.startOffset));
  const preferStart = Math.max(0, Math.min(video.duration || Infinity, eventTime - ongoingTest.preRoll));
  video.currentTime = (startPos > 0) ? startPos : preferStart;
  video.pause();
  setTimeout(()=>{
    ongoingTest.startPerfOffset = performance.now() - (video.currentTime * 1000) / (video.playbackRate || 1);
    ongoingTest.expectedEventPerfTime = ongoingTest.startPerfOffset + (eventTime * 1000) / (video.playbackRate || 1);
    ongoingTest.eventTriggered = false;
    ongoingTest.eventPerfTime = null;
    ongoingTest.trialStartWall = new Date().toISOString();
    video.play().then(()=>{
      trialInfo.textContent = `Próba ${trialIndex} / ${ongoingTest.trialsTotal} — gra. Naciśnij Space lub "Reaguj".`;
      ongoingTest.raf = requestAnimationFrame(pollVideo);
    }).catch(err=>{
      console.warn('Play rejected:', err);
      alert('Autoodtwarzanie zablokowane. Dotknij wideo, a potem kliknij Start ponownie.');
    });
  }, 140);
}

function pollVideo(){
  if (!ongoingTest || !ongoingTest.running) return;
  const vt = video.currentTime;
  if (!ongoingTest.eventTriggered && vt >= eventTime){
    const overshootMs = ((vt - eventTime) / (video.playbackRate || 1)) * 1000;
    const eventPerf = performance.now() - Math.max(0, overshootMs);
    ongoingTest.eventTriggered = true;
    ongoingTest.eventPerfTime = eventPerf;
  }
  ongoingTest.raf = requestAnimationFrame(pollVideo);
}

function reactNow(){
  if (!ongoingTest || !ongoingTest.running){
    alert('Brak trwającego testu.');
    return;
  }

  const pressPerf = performance.now();
  let reactionMs;

  if (ongoingTest.eventPerfTime != null) {
    reactionMs = pressPerf - ongoingTest.eventPerfTime;
  } else {
    const expected = ongoingTest.expectedEventPerfTime ?? pressPerf;
    reactionMs = pressPerf - expected;
  }

  // Zostawiono 30ms dla parametryzacji offsetu
  const reactionRounded = 30 + (Math.round(reactionMs * 10) / 10);

  try { video.pause(); } catch(e){}
  if (ongoingTest.raf) cancelAnimationFrame(ongoingTest.raf);

  ongoingTest.currentTrial += 1;
  const classification = classifyReaction(reactionRounded);
  const note = classification.valid ? 'OK' : 'Przewidziałeś';

  results.push({
    trial: ongoingTest.currentTrial,
    ms: reactionRounded,
    iso: new Date().toISOString(),
    note,
    rating: classification.label,
    valid: classification.valid,
    color: classification.color
  });

  updateResultsUI();

  setTimeout(()=>{
    if (ongoingTest.currentTrial < ongoingTest.trialsTotal) {
      runNextTrial();
    } else {
      ongoingTest.running = false;
      trialInfo.textContent = `Test zakończony. ${results.length} wyników.`;
      // po zakończeniu testu wykres jest już odświeżony przez updateResultsUI()
    }
  }, 700);
}

function stopTest(){
  if (!ongoingTest) return;
  ongoingTest.running = false;
  if (ongoingTest.raf) cancelAnimationFrame(ongoingTest.raf);
  try { video.pause(); } catch(e){}
  trialInfo.textContent = 'Test zatrzymany.';
}

function classifyReaction(ms){
  const m = Math.round(ms);
  if (m < 140) return { label: 'Przewidziałeś', valid: false, color: 'danger' };
  if (m <= 180) return { label: 'Rewelacja', valid: true, color: 'gold' };
  if (m <= 240) return { label: 'Bardzo dobrze', valid: true, color: 'green' };
  if (m <= 270) return { label: 'Dobrze', valid: true, color: 'orange' };
  return { label: 'Do poprawy', valid: true, color: 'muted' };
}

/* RESULTS UI + STATYSTYKI + WYKRES GAUSSA */
function updateResultsUI(){
  resultsBody.innerHTML = '';
  results.forEach((r, idx)=>{
    const tr = document.createElement('tr');

    const td1 = document.createElement('td'); td1.textContent = (idx+1);
    const td2 = document.createElement('td'); td2.textContent = r.iso;
    const td3 = document.createElement('td'); td3.textContent = `${r.ms} ms`; td3.style.fontWeight='700';

    const td4 = document.createElement('td');
    td4.textContent = r.rating || (r.note || '');
    if (r.valid === false) {
      td4.style.color = '#b00020';
      td4.style.fontWeight = '700';
    } else {
      if (r.color === 'gold') td4.style.color = '#b8860b';
      if (r.color === 'green') td4.style.color = '#0b8a3e';
      if (r.color === 'orange') td4.style.color = '#d06b00';
    }

    tr.appendChild(td1); 
    tr.appendChild(td2); 
    tr.appendChild(td3); 
    tr.appendChild(td4);
    resultsBody.appendChild(tr);
  });

  const validResults = results.filter(r => r.valid === true);
  const predictedCount = results.length - validResults.length;

  if (validResults.length < 3) {
    statsDiv.innerHTML = `
      Za mało prób do oceny powtarzalności.
      <span style="color:#b00020"> Przewidzianych: ${predictedCount}</span>
    `;
    drawEmptyGauss('Za mało danych do krzywej (min. 3 ważne próby).');
    return;
  }

  const nums = validResults.map(r => r.ms);
  const min = Math.min(...nums);
  const max = Math.max(...nums);

  const mean = nums.reduce((a,b)=>a+b,0) / nums.length;
  const variance = nums.reduce((sum, v)=>{
    return sum + Math.pow(v - mean, 2);
  }, 0) / nums.length;
  const stdDev = Math.sqrt(variance);

  let consistencyLabel = '';
  let consistencyColor = '';

  if (stdDev < 15) {
    consistencyLabel = 'ELITARNA POWTARZALNOŚĆ';
    consistencyColor = '#0b8a3e';
  } else if (stdDev < 30) {
    consistencyLabel = 'BARDZO DOBRA POWTARZALNOŚĆ';
    consistencyColor = '#2e7d32';
  } else if (stdDev < 50) {
    consistencyLabel = 'PRZECIĘTNA POWTARZALNOŚĆ';
    consistencyColor = '#d06b00';
  } else {
    consistencyLabel = 'NISKA POWTARZALNOŚĆ';
    consistencyColor = '#b00020';
  }

  statsDiv.innerHTML = `
    Powtarzalność (SD):<br/>
    <b style="color:${consistencyColor}">±${stdDev.toFixed(1)} ms</b><br/>
    • <b style="color:${consistencyColor}">${consistencyLabel}</b><br/>
    • Min: <b>${min.toFixed(1)} ms</b><br/>
    • Max: <b>${max.toFixed(1)} ms</b><br/>
    • Próby: ${validResults.length}
  `;

  if (predictedCount > 0) {
    statsDiv.innerHTML += `
      • <span style="color:#b00020">
        Przewidzianych (nie wliczane): ${predictedCount}
      </span>
    `;
  }

  // Aktualizacja wykresu Gaussa
  drawGaussCurve(nums, mean, stdDev);
}

/* Rysowanie wykresu Gaussa */
function drawEmptyGauss(msg){
  if (!gaussCtx) return;
  const ctx = gaussCtx;
  const W = gaussCanvas.width;
  const H = gaussCanvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#f5f7fb';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#888';
  ctx.font = '12px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Brak danych', W/2, H/2 - 8);
  if (msg){
    ctx.fillText(msg, W/2, H/2 + 10);
  }
  gaussInfo.textContent = msg || 'Wykres pojawi się po zakończeniu testu (min. 3 ważne próby).';
}

function drawGaussCurve(samples, mean, stdDev){
  if (!gaussCtx) return;
  const ctx = gaussCtx;
  const W = gaussCanvas.width;
  const H = gaussCanvas.height;

  ctx.clearRect(0,0,W,H);

  const paddingLeft = 35;
  const paddingRight = 10;
  const paddingTop = 10;
  const paddingBottom = 22;

  const plotW = W - paddingLeft - paddingRight;
  const plotH = H - paddingTop - paddingBottom;
  const baseY = H - paddingBottom;

  // Jedno miejsce – praktycznie idealna powtarzalność
  if (stdDev < 1e-3) {
    ctx.fillStyle = '#f5f7fb';
    ctx.fillRect(0,0,W,H);

    // oś X
    ctx.strokeStyle = '#ccd2e5';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, baseY);
    ctx.lineTo(W - paddingRight, baseY);
    ctx.stroke();

    const x = paddingLeft + plotW/2;
    ctx.strokeStyle = '#00AEEB';
    ctx.setLineDash([4,3]);
    ctx.beginPath();
    ctx.moveTo(x, baseY);
    ctx.lineTo(x, paddingTop);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = '#00AEEB';
    ctx.font = '11px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${mean.toFixed(1)} ms (idealnie powtarzalnie)`, x, paddingTop + 14);

    gaussInfo.textContent = `Średnia: ${mean.toFixed(1)} ms • SD ≈ 0 ms — prawie idealna powtarzalność.`;
    return;
  }

  const minSample = Math.min(...samples);
  const maxSample = Math.max(...samples);

  const left = Math.min(minSample, mean - 3*stdDev);
  const right = Math.max(maxSample, mean + 3*stdDev);
  const range = right - left || 1;

  function xToCanvas(val){
    return paddingLeft + ((val - left) / range) * plotW;
  }

  function normalPDF(x, mu, sigma){
    const z = (x - mu) / sigma;
    return Math.exp(-0.5 * z * z) / (sigma * Math.sqrt(2*Math.PI));
  }

  const steps = 120;
  const xs = [];
  const ys = [];
  let maxPdf = 0;
  for (let i=0;i<=steps;i++){
    const x = left + (range * i / steps);
    const pdf = normalPDF(x, mean, stdDev);
    xs.push(x);
    ys.push(pdf);
    if (pdf > maxPdf) maxPdf = pdf;
  }

  ctx.fillStyle = '#f5f7fb';
  ctx.fillRect(0,0,W,H);

  // oś X
  ctx.strokeStyle = '#ccd2e5';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(paddingLeft, baseY);
  ctx.lineTo(W - paddingRight, baseY);
  ctx.stroke();

  // Siatka pomocnicza i opis osi X (co 20 ms)
  const approxStep = 20;
  const startTick = Math.ceil(left / approxStep) * approxStep;
  const endTick = Math.floor(right / approxStep) * approxStep;
  ctx.fillStyle = '#99a1bd';
  ctx.font = '10px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  for (let t = startTick; t <= endTick; t += approxStep){
    const cx = xToCanvas(t);
    ctx.strokeStyle = '#eef1f8';
    ctx.beginPath();
    ctx.moveTo(cx, baseY);
    ctx.lineTo(cx, paddingTop);
    ctx.stroke();

    ctx.fillStyle = '#99a1bd';
    ctx.fillText(t.toFixed(0), cx, baseY + 3);
  }

  // Krzywa Gaussa
  ctx.strokeStyle = '#00AEEB';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ys.forEach((pdf, i)=>{
    const xVal = xs[i];
    const cx = xToCanvas(xVal);
    const norm = pdf / maxPdf;
    const cy = baseY - norm * plotH;
    if (i===0) ctx.moveTo(cx, cy);
    else ctx.lineTo(cx, cy);
  });
  ctx.stroke();

  // Średnia (μ)
  const meanX = xToCanvas(mean);
  ctx.strokeStyle = '#f9db2e';
  ctx.setLineDash([5,3]);
  ctx.beginPath();
  ctx.moveTo(meanX, baseY);
  ctx.lineTo(meanX, paddingTop);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = '#f9db2e';
  ctx.font = '11px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(`μ = ${mean.toFixed(1)} ms`, meanX, paddingTop + 14);

  // ±1σ
  const sigma1Left = xToCanvas(mean - stdDev);
  const sigma1Right = xToCanvas(mean + stdDev);
  ctx.strokeStyle = 'rgba(0,174,235,0.35)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sigma1Left, baseY);
  ctx.lineTo(sigma1Left, paddingTop+5);
  ctx.moveTo(sigma1Right, baseY);
  ctx.lineTo(sigma1Right, paddingTop+5);
  ctx.stroke();

  ctx.fillStyle = '#00AEEB';
  ctx.font = '10px system-ui, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('-1σ', sigma1Left - 2, paddingTop + 6);
  ctx.textAlign = 'left';
  ctx.fillText('+1σ', sigma1Right + 2, paddingTop + 6);

  // Pojedyncze próby jako kropki
  ctx.fillStyle = '#d06b00';
  samples.forEach(v=>{
    const cx = xToCanvas(v);
    const cy = baseY - 3;
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI*2);
    ctx.fill();
  });

  gaussInfo.textContent = `Średnia: ${mean.toFixed(1)} ms • SD: ±${stdDev.toFixed(1)} ms — im węższa krzywa, tym lepsza powtarzalność.`;
}

/* EXPORT CSV */
exportCsvBtn.addEventListener('click', ()=>{
  if (results.length === 0) { alert('Brak wyników do eksportu'); return; }
  const lines = [['trial','iso','ms','note']];
  results.forEach(r => lines.push([r.trial, r.iso, r.ms, r.note]));
  const csv = lines.map(l=>l.map(cell=> `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'reaction_results.csv'; a.click();
  URL.revokeObjectURL(url);
});

/* INITIALIZE on load */
window.addEventListener('load', ()=>{
  const stored = parseFloat(localStorage.getItem('fly_zoom') || '1');
  if (!isNaN(stored)){ scale = stored; updateTransform(); }
  updateResultsUI();
});

/* reset transform on double-tap/click on transformer */
transformer.addEventListener('dblclick', ()=>{
  scale = 1; tx = 0; ty = 0; updateTransform();
});

/* Small UX: when video loads metadata */
video.addEventListener('loadedmetadata', ()=>{
  if (window.innerWidth < 600 && scale === 1) { scale = 1.15; updateTransform(); }
});

/* Prevent accidental drag of video element */
video.addEventListener('dragstart', (e)=> e.preventDefault());
</script>
</body>
</html>
